[{"categories":["Non-technical"],"contents":"Hey Guys, the year is 2026 and I am bringing this blog back from the grave.\nI always wanted to give this blog more chaotic vibes, like early days internet ( back when internet was cool ). I wanted it to be about technical topics that I like, but also about random topics like recipes and \u0026hellip; music.\nSo I can\u0026rsquo;t think about anything better to start this new phase other than writting about some cool bands I\u0026rsquo;ve been listening to.\nHave a look on my recommendations ü§ò:\n‚ñ∂Ô∏è If you like instrumental rock while coding, you have to check this one. These guys from Greece never disappoint. I found the title itself to be very interesting, also. I have the impression that modern academia became a place of inflated egos and kind of forgot that making science has to be, first of all, joyful.\n‚ñ∂Ô∏è This guys from Argentina came up with, perhaps, one of the coolest albums I discovered in 2024. As a side note: I hate that the Brazilians and Argentinians boomers created this nonsense rivalry between us. C\u0026rsquo;mon, listen to this guys.\n‚ñ∂Ô∏è This next one I found by chance while walking around the lake Lugano, Switzerland, in a random evening. They were putting an absolutely killer perfomance in a small open air stage to about 20 people. The funny fact about this evening is that there was a big, well equipped, stage close to this small stage. Only a few moments after they finished, some girls started perfoming on this bigger stage and they were so bad that that I\u0026rsquo;d rather listen to nails on a chalkboard. This big stage area was packed with people. Go figure!\n‚ñ∂Ô∏è I\u0026rsquo;ve listened to Protomartyr for the first time around 2023 and they haven\u0026rsquo;t left my playlist since then. The videoclip of this one is a must see, btw. ( For context: It is about the mythical battle between Galerito and Gil da esfiha. )\n‚ñ∂Ô∏è If you like analog synths, you have to check Ehsan Gelsi. He puts up great tracks to listen while coding.\nOpening üì∏ by Sophie Keen on Unsplash\n","permalink":"https://eddieliberato.github.io/blog/2026-01-01-some-cool-songs/","tags":["Music"],"title":"Some Cool Songs üîä"},{"categories":["Programming"],"contents":"The title says it all, but I will elaborate a bit more.\nWhen I started this blog I had the intention of writing about parametric 3d design using open source software. Years have gone by, and I am now deciding to have a more open approach and write about everything that I feel like. To make things a bit more organized I am putting all the blog entries from 2018 to 2020 in this single one. The table of contents below should help in jumping quickly to whatever you find interesting.\nIf you are wondering why I left the dogbones as a separate blog post, here is the answer: This is by far the page with the most hits on my blog. Americans seem to like it, and for that reason I decided to leave it untouched. Thinking about it I can see it as a great model to show the benefits of parametric design. Only a few lines of code and TA-DA, you\u0026rsquo;ve got your model and you can easily modify the dimensions as you wish. Simple and efficient, CAD guru stuff.\nI also left the chess set post as a historical landmark, after all it was the first blog post on this platform (github pages), by coincidence, exactly 4 years ago.\nFinal thing I want to mention: Looking at the analytics of the website, no one seems to care about the kugelwellen horn. I personally find this kind of design, that uses physics equations to model things, of great value on the skill-set of an engineer.\nTable of Contents Turners Cube (04/07/2018) CD Organizer (18/08/2018) Kugelwellenhorn (19/08/2018) Dovetail Guide (01/04/2019) Sawing Guides (08/05/2020) Parametric Spiral Lampshade (11/05/2020) Plywood Connectors (13/05/2020) Man Against Washing Machine (15/05/2020) Parametric Stepper Motor Bracket (01/02/2020) A screwed knob (10/03/2022) Turners Cube (04/07/2018) Back in Brazil, during my machinist apprenticeship, one of the lathe tasks of the manual machining course was to make a turners cube (outlined on the image above üëÜ). Basically you need to turn a cube in the lathe and make some holes, that if carefully bored to specific dimensions, you end up with usually two captive cubes inside one another. At the time I was only a young teenager and the captive cube was a very attractive challenge to me. I naively thought that only round parts could be made at the lathe, so I was impressed with the cube with other cubes inside coming out of the machine. Sadly nowadays I don\u0026rsquo;t know anymore where mine is. Hopefully at my mom\u0026rsquo;s place.\nYou can have as many cubes as you want inside. Back then, the ones who actually made the cube usually went for three and so I did and I still think that three is the right number if you\u0026rsquo;re doing it on the manual lathe. Two is too easy. Four is annoying because there is a lot of repetition of the same operations. Three is a good number because you proved your point in showing the instructor what you\u0026rsquo;re capable of, and is not as annoying to make as the four cubes version.\nLeaving 2003 behind and back to 2018, I was thinking that the repetitive nature of the object makes it a nice model for cadqquery. So here is the script that I came up with:\nimport cadquery as cq from math import sqrt captive_cube_size = 10 # mm n_of_cubes = 3 # besides the innermost captive cube small_holes = True # False = innermost captive cube without holes cube_size = captive_cube_size*2**n_of_cubes # total size of the cube sh_size = captive_cube_size/sqrt(2) # diameter of the hole on the smallest cube cube = cq.Workplane(\u0026#34;front\u0026#34;).box(cube_size, cube_size, cube_size) for x in range(n_of_cubes): cube = cube.faces(\u0026#34;\u0026gt;X\u0026#34;).workplane(centerOption=\u0026#39;CenterOfBoundBox\u0026#39;).hole(captive_cube_size*(sqrt(2)**(2*x+1)), (cube_size-captive_cube_size*2**x)/2) cube = cube.faces(\u0026#34;\u0026gt;Y\u0026#34;).workplane(centerOption=\u0026#39;CenterOfBoundBox\u0026#39;).hole(captive_cube_size*(sqrt(2)**(2*x+1)), (cube_size-captive_cube_size*2**x)/2) cube = cube.faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane(centerOption=\u0026#39;CenterOfBoundBox\u0026#39;).hole(captive_cube_size*(sqrt(2)**(2*x+1)), (cube_size-captive_cube_size*2**x)/2) cube = cube.faces(\u0026#34;\u0026lt;X\u0026#34;).workplane(centerOption=\u0026#39;CenterOfBoundBox\u0026#39;).hole(captive_cube_size*(sqrt(2)**(2*x+1)), (cube_size-captive_cube_size*2**x)/2) cube = cube.faces(\u0026#34;\u0026lt;Y\u0026#34;).workplane(centerOption=\u0026#39;CenterOfBoundBox\u0026#39;).hole(captive_cube_size*(sqrt(2)**(2*x+1)), (cube_size-captive_cube_size*2**x)/2) cube = cube.faces(\u0026#34;\u0026lt;Z\u0026#34;).workplane(centerOption=\u0026#39;CenterOfBoundBox\u0026#39;).hole(captive_cube_size*(sqrt(2)**(2*x+1)), (cube_size-captive_cube_size*2**x)/2) if small_holes: cube = cube.faces(\u0026#34;\u0026lt;X\u0026#34;).workplane(centerOption=\u0026#39;CenterOfBoundBox\u0026#39;).hole(sh_size) cube = cube.faces(\u0026#34;\u0026lt;Y\u0026#34;).workplane(centerOption=\u0026#39;CenterOfBoundBox\u0026#39;).hole(sh_size) cube = cube.faces(\u0026#34;\u0026lt;Z\u0026#34;).workplane(centerOption=\u0026#39;CenterOfBoundBox\u0026#39;).hole(sh_size) I based my script in the innermost captive cube and in the square root of 2, which is a number associated with circles and squares. That makes the cube look good and proportional. The drawback is that the final size grows quadratically with the number of cubes resulting in a big thing if you go for a lot of cubes.\nCD Organizer (18/08/2018) I had some old CDs lying around the house and I decided to organize them in a single place. I thought of 3d printing something to help, but after a brief search around the internet I couldn\u0026rsquo;t find anything that I liked. The ones I could find were big and clunky, leading to long printing times. The \u0026ldquo;simple\u0026rdquo; one (that wasn\u0026rsquo;t simple at all) that I found had the slots a bit undersized and I couldn\u0026rsquo;t fit the CDs. I could have re-scaled the model but that print took me around 3 hours and I started to wonder if I should repeat it.\nI decided to come up with my own design.\nimport cadquery as cq slots = 8 # number slots (number of CDs in this case) slot_width = 11.0 # mm, slot size (slightly bigger than a CD case width) slot_depth = 20.0 # mm slot_length = 140.0 # mm thickness_wall = 0.8 # mm thickness_bottom = 2.0 # mm spacing = slot_width + thickness_wall cdorg = cq.Workplane(\u0026#34;front\u0026#34;).box(slot_length+thickness_wall, spacing*slots+thickness_wall, slot_depth+thickness_bottom) .\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().center(thickness_wall,-(spacing/2*(slots-1))).pushPoints([(0, y * spacing) for y in range(0, slots)]).rect(slot_length+thickness_wall, slot_width).cutBlind(-slot_depth).\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).rect(slot_length/1.6, spacing*slots+thickness_wall).cutBlind(-slot_depth) The print took only 14 minutes because I could take advantage of the 0.8mm nozzle and print the walls in a single pass of the hotend. The design turned out to be not super visually appealing but the function was on point. It keeps the CDs more accessible than just piling them up and it makes everything more stable against tipping over.\nMore important than the physical object itself was that I learned something. I find this method of using the for loop (python\u0026rsquo;s list comprehension) inside the pushPoints method very elegant and I plan to reuse this code for lathe tools and drill bits organizers among others.\nKugelwellenhorn (19/08/2018) I have always been intrigued by horns. Actually by passive devices in general; tuned mass dampers, RLC circuits to name a few. Researching more about horns I found two designs that I\u0026rsquo;d like to explore more. One is the Kugelwellenhorn and the other is the Le Cleah\u0026rsquo;c horn. More info about the former can be found here, in a lecture apparently gaven by Le Cleach\u0026rsquo;c himself when he was still alive.\nAbout Kugellwellen horn, the design that I decided to approach first, all the info you need you can probably find on the site of Bjorn Kolbrek. Kolbrek seems to be an expert on the subject, and I enjoyed reading his articles. The math on his reports was a bit beyond my comprehension and I didn\u0026rsquo;t want to dive so deep into the subject. My goal was only to design and materialize the horn. Turns out that this is not hard at all, Just take a look at the script below and you\u0026rsquo;ll see that all you need is about 30 lines of code.\nimport cadquery as cq from math import pi, sqrt, exp td = 12 # mm, throat diameter steps = 450 # related to the length of the horn fc = 480 # Hz, cuttof frequency c = 344000 # mm/s, speed of sound through air m = 4*pi*fc/c y0 = td/2 r0 = c/(pi*fc) h0 = r0 - sqrt(r0*r0-y0*y0) s0 = 2*pi*r0*h0 edg_points = [] for x in range(steps): h = h0*exp(m*x) s = 2*pi*r0*h y = sqrt((s/pi)-h*h) xh = x-h+h0 edg_points.append([y, xh]) edg_points[0] = [y0, 0] horn = cq.Workplane(\u0026#34;XY\u0026#34;).move(y0, 0).spline(edg_points).wire().revolve() Lecleach suggests that it\u0026rsquo;s important to shape the horn past 180 degrees but as you can see it can be tricky to 3d print the involute part of the horn. Would be interesting to come up with some 3D printing hack to print the involute. Maybe one day I will come back to this topic to try something in this direction. (Message from the future: It never happened, I never got back to this.)\nDovetail Guide (01/04/2019) This is my take on dovetail guides, I designed this to be 3d printed and parametric. Using parametric design makes it very easy to tune the dovetail ratio and to fit different magnets that one may have at hand. Higher ratios (e.g 1:8) are good for hardwoods and lower ratios (e.g. 1:5) are better suited for softwoods.\nSeveral models can be found on the internet and I would like to buy one but with all the import taxes it becomes expensive. Also I don\u0026rsquo;t know what ratio I want exactly, so it makes sense to print my own to experiment with.\nI was particularly inspired by David Barron and as seen in his videos, the simple jig works with magnets that hold the saw in place, making the dovetail cutting process easier.\nimport cadquery as cq # A simple dovetail saw guide for woodworking size = 40.0 #mm, size of the blank ratio = 6 #dovetail ratio e.g. 1:6. tab_top = 15.0 #mm, thickness of the top tab tab_back = 15.0 #mm, thickness of the back tab magnet_diameter = 5.2 #mm magnet_thickness = 8.5 #mm magnet_spacing_between = 24.0 #mm embossing = True dovetail_guide = cq.Workplane(\u0026#34;top\u0026#34;).rect(size, size).workplane(offset=size).rect(size-(size/float (ratio))*2, size).loft(combine=True) .\\ faces(\u0026#34;\u0026gt;Y\u0026#34;).workplane().transformed(offset=(0, -tab_top, 0)).rect(size, size).cutBlind(-size+tab_back) .\\ faces(\u0026#34;\u0026gt;X\u0026#34;).workplane(centerOption=\u0026#39;CenterOfBoundBox\u0026#39;).pushPoints([(-magnet_spacing_between/2,size/2-tab_top/2), (magnet_spacing_between/2,size/2-tab_top/2)]).hole(magnet_diameter, magnet_thickness) .\\ faces(\u0026#34;\u0026lt;X\u0026#34;).workplane(centerOption=\u0026#39;CenterOfBoundBox\u0026#39;).pushPoints([(size/2-tab_back/2, -magnet_spacing_between/2), (size/2-tab_back/2, magnet_spacing_between/2)]).hole(magnet_diameter, magnet_thickness) if embossing: dovetail_guide = dovetail_guide.faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane(centerOption = \u0026#39;CenterOfBoundBox\u0026#39;).text(\u0026#34;1:\u0026#34;+str(ratio), 8, -1, cut=True, combine=False, clean=True, font=\u0026#39;Arial\u0026#39;, kind=\u0026#39;regular\u0026#39;, halign=\u0026#39;center\u0026#39;, valign=\u0026#39;center\u0026#39;) Sawing Guides (08/05/2020) The idea here is the same as my dovetail jig but now one is intended to aid making square cuts on wood with hand saws and the other 45 degrees cut for joinery.\nI put the option of having a recess on these two jigs for clearance between the saw and the jig itself. I realized that depending on how you execute the cut the saw may bite the jig. It doesn\u0026rsquo;t alter the performance of the jig, but it leaves scratch marks. Cutting a recess on the dovetail jig makes it unbalanced but these two not, at least in my opinion.\nimport cadquery as cq # A simple woodworking jig for guiding a saw at right angles. size = 50.0 # mm, size of the blank width = 35.0 # mm tab_top = 18.0 # mm, thickness of the top tab tab_back = 12.0 # mm, thickness of the back tab magnet_diameter = 5.2 # mm magnet_thickness = 8.5 # mm magnet_spacing_between = 30.0 # mm clearance = True clearance_size = 2.0 # mm right_angle_guide = cq.Workplane(\u0026#34;top\u0026#34;).box(width, size, size).\\ faces(\u0026#34;\u0026gt;X\u0026#34;).workplane(centerOption=\u0026#39;CenterOfBoundBox\u0026#39;).pushPoints([(-magnet_spacing_between/2, size/2-tab_top/2), (magnet_spacing_between/2, size/2-tab_top/2)]).hole(magnet_diameter, magnet_thickness) .\\ faces(\u0026#34;\u0026lt;Y\u0026#34;).workplane(centerOption=\u0026#39;CenterOfBoundBox\u0026#39;, offset=-tab_back).move(0, -tab_top/2).rect(size, size-tab_top).cutBlind(\u0026#34;next\u0026#34;) if clearance: right_angle_guide = right_angle_guide.faces(\u0026#34;\u0026gt;X\u0026#34;).workplane(centerOption=\u0026#39;CenterOfBoundBox\u0026#39;).move(0, -tab_top).rect(size, size).cutBlind(-clearance_size) import cadquery as cq # A simple 45 degrees hand saw guide for woodworking size = 40.0 # mm, height and lenght and of the guide. The width is double this value tab_top = 18.0 # mm, thickness of the top tab tab_back = 12.0 # mm, thickness of the back tab magnet_diameter = 5.2 # mm magnet_thickness = 8.5 # mm magnet_spacing_between = 30.0 # mm clearance = True clearance_size = 2.0 # mm guide = cq.Workplane(\u0026#34;front\u0026#34;).lineTo(size*2, 0).lineTo(size, size).close().extrude(size) .\\ faces(\u0026#34;\u0026gt;X\u0026#34;).workplane(centerOption=\u0026#39;CenterOfBoundBox\u0026#39;).pushPoints([(-magnet_spacing_between/2, size/2-tab_top/2), (magnet_spacing_between/2, size/2-tab_top/2)]).hole(magnet_diameter, magnet_thickness) .\\ faces(\u0026#34;\u0026lt;Y\u0026#34;).workplane(centerOption=\u0026#39;CenterOfBoundBox\u0026#39;, invert=True, offset=tab_back).move(0, tab_top/2).rect(size*2, size-tab_top).cutBlind(size) if clearance: guide = guide.faces(\u0026#39;\u0026gt;(1,1,0)\u0026#39;).workplane(centerOption=\u0026#39;CenterOfBoundBox\u0026#39;).move(0, -tab_top).rect(size*1.6, size).cutBlind(-clearance_size) Recently I got myself a Gyokucho 615 and I could test it with the jig. No need to say it works like a charm. The cut was square and the texture of the end grain after the cut was very smooth. What a saw, btw! I managed to make a few frames with this setup.\nParametric Spiral Lampshade (11/05/2020) import cadquery as cq length = 150.0 # mm max_height = 150.0 # mm height_increment = 15.0 # mm, Z axis increment per step rotation_step = 10 # degrees, rotation of the XY plane per step growth_factor = 1.1 # maybe decrease factor ? ¬Ø\\_(„ÉÑ)_/¬Ø spiral_lampshade = cq.Workplane(\u0026#34;front\u0026#34;).rect(length/1.618, length) .\\ workplane(offset=height_increment).rect(length/1.618, length) .\\ loft(combine=True) next_len = float (0) height = float (0) rotation = rotation_step while height \u0026lt;= max_height-height_increment: next_len = length/growth_factor spiral_lampshade = spiral_lampshade.faces(\u0026#34;\u0026gt;Z\u0026#34;).rect(length/1.618, length).workplane().transformed(offset=(0, 0, height_increment), rotate=(0, 0, rotation)).rect(next_len/1.618, next_len).loft(combine=True) length = next_len rotation += rotation_step height = height+height_increment show_object(spiral_lampshade) Plywood Connectors (13/05/2020) I made this about two years ago and even though I liked the outcome pretty much I decided not to post anything about it at the time.\nI didn\u0026rsquo;t want to harm in any way the company that makes the original but at this point it doesn\u0026rsquo;t make any sense to hold back, googling \u0026ldquo;plywood connectors\u0026rdquo; or \u0026ldquo;wood connectors DIY furniture\u0026rdquo; you will find a vast amount of Chinese knockoffs.\nAt the time of writing I found this on the internet. Another interesting thing I found was this aluminium version where they claim to be in business since 2013.\nI first learned about this by the name of playwood. I found it when I was looking for a small bookshelf DIY project. There are some reasons why I didn\u0026rsquo;t buy directly from these guys. First, they are not super expensive but you need quite a few in order to make something useful, then, with post and import taxes it starts to become expensive. Second, I have 3d printers and I like to make stuff.\nAs always, I kept the design as minimalist as possible. My version takes a socket head cap screw on one side and a hex nut on the other side. I\u0026rsquo;ve used M6 screws because it was what I had at hand at the time but I\u0026rsquo;m pretty sure smaller screws are also OK for this application.\nimport cadquery as cq from math import cos, sqrt, pi # shared parameters thickness = 12.0 # mm width = 10.0 # mm screw_clearance = 6.8 # mm, diameter of the screw + some clearance # outer jaw parameters oface_length = 38.0 # mm outer face length oleg_length = 42.0 # mm outer leg length support_height = 4.0 # mm, I\u0026#39;m calling support this small bump where the plywood butt will rest against # minimum plywood thickness it will hold = sqrt(2)*support_height BTW counterBore_diameter = 11.2 # mm screwHead_height = 6.0 # mm # inner jaw parameters # This inner leg lenght is just a recomendation, it will be flush with the outer jaw leg ileg_length = oleg_length-(thickness+support_height)*sqrt(2) # mm #inner jaw hardware parameters nut_thickness = 5.0 # mm nut_widthAcrossCorners = 12.0 # mm ojaw = (cq.Workplane(\u0026#34;front\u0026#34;).line(-oface_length/2, 0). line(-cos(pi/4)*oleg_length, cos(pi/4)*oleg_length). line(thickness*sqrt(2), 0). line((cos(pi/4)*oleg_length-thickness), -cos(pi/4)*oleg_length+thickness). line(support_height, support_height). lineTo(0, thickness+support_height).mirrorY().extrude(width, both=True). faces(\u0026#34;\u0026lt;Y\u0026#34;).workplane().cboreHole(screw_clearance, counterBore_diameter, screwHead_height)) ijaw = (cq.Workplane(\u0026#34;front\u0026#34;).line(-(oface_length-(thickness*sqrt(2)-thickness)*2-support_height*2)/2, 0). line(-cos(pi/4)*ileg_length, cos(pi/4)*ileg_length). line(thickness, 0). line((cos(pi/4)*ileg_length-thickness), -cos(pi/4)*ileg_length+thickness). lineTo(0, thickness).mirrorY().extrude(width, both=True). faces(\u0026#34;\u0026lt;Y\u0026#34;).workplane().hole(screw_clearance). faces(\u0026#34;\u0026gt;Y[-2]\u0026#34;).workplane().polygon(6, nut_widthAcrossCorners).cutBlind(-nut_thickness). translate((0,thickness+support_height,0))) Man Against Washing Machine (15/05/2020) One of my personal favorite uses of 3d printers at home is to fix broken stuff. This object is not special but I\u0026rsquo;m posting it here because it involves modeling parametric threads.\nThis is a simple trapezoidal thread. For something more elaborate, check the last entry of this post.\nimport cadquery as cq from math import sin, cos, pi lenght = 32 minor_diameter = 18.0 pitch = 4.9 pts = [] for t in range(lenght): x = minor_diameter/2*cos(t) y = minor_diameter/2*sin(t) z = pitch/(2*pi)*t # helix lenght pts.append([x,y,z]) path = cq.Workplane(\u0026#34;XY\u0026#34;).spline(pts).wire() thread = cq.Workplane(\u0026#34;XZ\u0026#34;).move(minor_diameter/2, 0).line(3.2, 0.5).line(0,1.0).line(-3.2, 0.5).close().sweep(path, isFrenet=True) foot = cq.Workplane(\u0026#34;XY\u0026#34;).circle(18.5/2.0).extrude(26.0) .\\ faces(\u0026#34;\u0026lt;Z\u0026#34;).workplane().circle(25.0/2.0).extrude(5.0) .\\ faces(\u0026#34;\u0026lt;Z\u0026#34;).workplane().polygon(8, 44.0).extrude(14.0) .\\ faces(\u0026#34;\u0026lt;Z\u0026#34;).workplane().hole(14.0, 42.0).translate((0,0,pitch/2.0)) foot = foot.union(thread) This object is a washing machine adjustment pad that went missing (don\u0026rsquo;t ask me how). At least there were 3 left so I could replicate the missing one. The tolerance on the mating thread was big, because even printing without support on my cheap 3d printer, it worked in the first attempt! No second iteration was needed :)\nParametric Stepper Motor Bracket (01/02/2020) The price estimations that I received for this object to have it made out of welded steel (by professional welders), were in the 100-130 EUROS range, 10 days delivery time. As the application intended for it had a light load I decided to just model and 3d print it. Took me half an hour of 3d modeling and 4 hours for the 3d printing process. I printed it out of ABS on a professional grade printer from the university.\nimport cadquery as cq width = 66.0 # mm fplate_height = 60.0 # mm fplate_thickness = 10.0 # mm fplate_between_holes = 47.1 # mm, rectangular distance between stepper mounting holes (NEMA 23 = 47.1) fplate_screw_clearance = 5.0 # mm fplate_cbore_diameter = 7.5 # mm fplate_cbore_depth = 4.0 # mm main_bore_diameter = 28.2 # mm main_cbore_diameter = 40.0 # mm main_cbore_depth = 2.0 # mm bplate_length = 86.0 # mm bplate_thickness = 4.0 # mm bplate_between_holes = 50.0 # mm, holes to mount it to the frame bplate_holes_offset = 5.0 # mm bplate_screw_clearance = 5.0 # mm bplate_cbore_diameter = 7.5 # mm bplate_cbore_depth = 2.0 # mm gusset_thickness = 3.0 # mm gusset = True stepper_bracket = cq.Workplane(\u0026#34;front\u0026#34;).box(width, fplate_thickness, fplate_height+bplate_thickness) .\\ faces(\u0026#34;\u0026gt;Y\u0026#34;).workplane().move(0, bplate_thickness/2).rect(fplate_between_holes, fplate_between_holes, forConstruction=True) .\\ vertices().cboreHole(fplate_screw_clearance, fplate_cbore_diameter, fplate_cbore_depth) .\\ faces(\u0026#34;\u0026lt;Y\u0026#34;).workplane().move(0, bplate_thickness/2).cboreHole(main_bore_diameter, main_cbore_diameter, main_cbore_depth) .\\ faces(\u0026#34;\u0026lt;Y\u0026#34;).workplane(centerOption=\u0026#39;CenterOfBoundBox\u0026#39;).move(0, -fplate_height/2).rect(width, bplate_thickness).extrude(bplate_length) .\\ faces(\u0026#34;\u0026lt;Z[1]\u0026#34;).workplane().move(0, bplate_holes_offset).rect(bplate_between_holes, bplate_between_holes, forConstruction=True) .\\ vertices().cboreHole(bplate_screw_clearance, bplate_cbore_diameter, bplate_cbore_depth) if gusset: stepper_bracket = stepper_bracket.faces(\u0026#34;\u0026gt;X\u0026#34;).workplane(centerOption=\u0026#39;CenterOfBoundBox\u0026#39;).move(0, -(fplate_height+bplate_thickness)/2) .\\ line((bplate_length+fplate_thickness)/2, 0).line(0, fplate_height).close().extrude(-gusset_thickness) .\\ faces(\u0026#34;\u0026lt;X\u0026#34;).workplane(centerOption=\u0026#39;CenterOfBoundBox\u0026#39;).move(0, -(fplate_height+bplate_thickness)/2) .\\ line(-(bplate_length+fplate_thickness)/2, 0).line(0, fplate_height).close().extrude(-gusset_thickness) A screwed knob (10/03/2022) I don\u0026rsquo;t know why but the 3d printer comes from the factory with a lock and key. I decided to just swap it with a simple knob. It would be a nice test print, So I designed a knob with a threads that fit the nut from the keylock that came with the machine.\nHere follows the cadquery code for the design.\nimport cadquery as cq from cadquery import * from math import sin, cos, pi def helix(r0,r_eps,p,h,d=0,frac=1e-1): def func(t): if t\u0026gt;frac and t\u0026lt;1-frac: z = h*t + d r = r0+r_eps elif t\u0026lt;=frac: z = h*t + d*sin(pi/2 *t/frac) r = r0 + r_eps*sin(pi/2 *t/frac) else: z = h*t - d*sin(2*pi - pi/2*(1-t)/frac) r = r0 - r_eps*sin(2*pi - pi/2*(1-t)/frac) x = r*sin(-2*pi/(p/h)*t) y = r*cos(2*pi/(p/h)*t) return x,y,z return func def thread(radius, pitch, height, d, radius_eps, aspect= 10): e1_bottom = (cq.Workplane(\u0026#34;XY\u0026#34;) .parametricCurve(helix(radius,0,pitch,height,-d)).val()) e1_top = (cq.Workplane(\u0026#34;XY\u0026#34;) .parametricCurve(helix(radius,0,pitch,height,d)).val()) e2_bottom = (cq.Workplane(\u0026#34;XY\u0026#34;) .parametricCurve(helix(radius,radius_eps,pitch,height,-d/aspect)).val()) e2_top = (cq.Workplane(\u0026#34;XY\u0026#34;) .parametricCurve(helix(radius,radius_eps,pitch,height,d/aspect)).val()) f1 = Face.makeRuledSurface(e1_bottom, e1_top) f2 = Face.makeRuledSurface(e2_bottom, e2_top) f3 = Face.makeRuledSurface(e1_bottom, e2_bottom) f4 = Face.makeRuledSurface(e1_top, e2_top) sh = Shell.makeShell([f1,f2,f3,f4]) rv = Solid.makeSolid(sh) return rv radius = 10.0 pitch = 1.8 height = 5 d = pitch/4 radius_eps = 0.5 eps=1e-3 core = cq.Workplane(\u0026#34;XY\u0026#34;,origin=(0,0,-d)).circle(radius+eps).extrude(height+1.75*d) th1 = thread(radius,pitch,height,d,radius_eps) handle = cq.Workplane(\u0026#34;XY\u0026#34;).rect(20.0, 20.0).extrude(2.5) .\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().rect(22.0, 22.0).extrude(3.0) .\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().rect(22.0, 6.0) .\\ workplane(offset=16.0).rect(14.0, 2.0).loft(combine=True) .\\ edges(\u0026#34;|Z\u0026#34;).chamfer(4.0).translate((0,0,5.3)) res = core.union(th1).union(handle) Can we take a moment to appreatiate the entry of the threads? (exit is similar, but not shown here). I think that\u0026rsquo;s super nice!\nWell, that\u0026rsquo;s it for the moment!\nCheers,\nEdi\n","permalink":"https://eddieliberato.github.io/blog/2022-06-26-cadquery-models-collection/","tags":["Cad","3d printing","Cadquery"],"title":"A Collection of Cadquery Parametric Models (2018-2022)"},{"categories":["Programming"],"contents":"Sometime ago I acquired a jetson nano 2gb SBC and after using it a bit I felt the need to overclock it. The problem is that it runs hot even at default clock speeds, so I needed a fan. But the fan needs to be mounted somewhere right?\nYes there is some holes on the big heatsink that comes with the board but the silicone screws that come with the noctua fan don\u0026rsquo;t fit. Maybe a 3d printed case with fan mounts will do it, I thought to myself.\nUnfortunately, none of the 3d printed cases I found on the web could sit on standing up position as I wanted, So I decided to make my own.\nThe 3d printed case The project here is a jetson nano case with fan support. The 4 main goals of this design:\nThe case should allow flat and upright orientation, as the former takes advantage of natural convection. It should look good, because it will be on the tv rack. Access to the GPIO pins should be easy (that\u0026rsquo;s the reason for the split dust cover). The fan should mount on the case, allowing the use of the silicone mounts that comes in the box of the noctua fan. The reason for this is to avoid the need of extra hardware. I used cadquery to model the case and cover. It was easy to dial in the dimensions this way.\nimport cadquery as cq # board cover board_length = 102.0 board_width = 81.0 height = 13.0 shell_thickness = 0.9 mount_holes_offset_x =4.8 mount_holes_offset_y =18.0 usbc_offset = 1.8 usbc_width = 10.0 usbc_height = 5.0 hdmi_offset = 16.0 hdmi_width = 16.5 hdmi_height = 9.0 singleusb_offset = 35.0 singleusb_width = 16.0 singleusb_height = 10.0 doubleusb_offset = 53.0 doubleusb_width = 16.0 doubleusb_height = 18.0 ether_offset = 68.0 ether_width = 18.0 ether_height = 18.0 usbb_offset = 88.0 usbb_width = 9.0 usbb_height = 5.0 cover = cq.Workplane(\u0026#34;front\u0026#34;).box(board_length, board_width, height, centered=False) .\\ faces(\u0026#34;\u0026lt;Z\u0026#34;).shell(shell_thickness) .\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().move(18.0, 40.0).rect(61.0, 48.0, centered=False).cutThruAll() .\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().move(65.0, 0).rect(14.0, board_width, centered=False).cutThruAll() .\\ faces(\u0026#34;\u0026gt;Z[-2]\u0026#34;).workplane().move(mount_holes_offset_x, -mount_holes_offset_y).rect(86.0, -58.0, centered=False, forConstruction=True).vertices().circle(2.0).extrude(height-3.0) .\\ faces(\u0026#34;\u0026gt;Z[-2]\u0026#34;).workplane().move(mount_holes_offset_x, -mount_holes_offset_y).rect(86.0, -58.0, centered=False, forConstruction=True).vertices().circle(1.25).extrude(height) .\\ faces(\u0026#34;\u0026lt;Y[-2]\u0026#34;).workplane().rect(-board_length,-height, centered=False).extrude(10.0) .\\ faces(\u0026#34;\u0026lt;Z\u0026#34;).workplane().move(usbc_offset, -10.0).rect(usbc_width, 10.0+shell_thickness, centered=False).cutBlind(-usbc_height) .\\ faces(\u0026#34;\u0026lt;Z\u0026#34;).workplane().move(hdmi_offset, -10.0).rect(hdmi_width ,10.0+shell_thickness, centered=False).cutBlind(-hdmi_height) .\\ faces(\u0026#34;\u0026lt;Z\u0026#34;).workplane().move(singleusb_offset, -10.0).rect(singleusb_width ,10.0+shell_thickness, centered=False).cutBlind(-singleusb_height) .\\ faces(\u0026#34;\u0026lt;Z\u0026#34;).workplane().move(doubleusb_offset, -18.2).rect(doubleusb_width ,24.0, centered=False).cutBlind(-doubleusb_height) .\\ faces(\u0026#34;\u0026lt;Z\u0026#34;).workplane().move(ether_offset, -22.5).rect(ether_width ,24.0, centered=False).cutBlind(-ether_height) .\\ faces(\u0026#34;\u0026lt;Z\u0026#34;).workplane().move(usbb_offset, -10.0).rect(usbb_width ,10.0+shell_thickness, centered=False).cutBlind(-usbb_height) .\\ faces(\u0026#34;\u0026lt;Z\u0026#34;).workplane().move(0, -1.0).rect(board_length, -10.0, centered=False).cutBlind(-3.0) cover = cover.translate((3, shell_thickness, 3)) # case case_length = 105 case_height = 52 case_thickness = 1.5 top_thickness = 3.0 holes_offset_x = -2.0 holes_offset_y = 18.0 case_back = cq.Workplane(\u0026#34;front\u0026#34;).box(case_length+case_thickness, board_width+shell_thickness*2, shell_thickness, centered=False) .\\ faces(\u0026#34;\u0026lt;Z\u0026#34;).workplane().rect(case_thickness/2.0, -40.0, centered=False).extrude(-case_height-case_thickness) .\\ faces(\u0026#34;\u0026lt;Z\u0026#34;).workplane().move(case_length+case_thickness/2.0, 0).rect(case_thickness/2.0, -board_width-shell_thickness*2, centered=False).extrude(-case_height-case_thickness) .\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().rect(10.0, 40.0, centered=False).extrude(-10.0) .\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().move(case_length+case_thickness/2.0, 0).rect(-10.0, +board_width+shell_thickness*2, centered=False).extrude(-10.0) .\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().pushPoints([(5.0, 20.0 ), (100.0+case_thickness, 10.0), (100.0+case_thickness, 71.0)]).hole(4.6, 10.0) case_top = cq.Workplane(\u0026#34;front\u0026#34;).box(case_length+case_thickness, board_width+shell_thickness*2, top_thickness, centered=False) .\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().pushPoints([(5.0, 20.0 ), (100.0+case_thickness, 10.0), (100.0+case_thickness, 71.0)]).cskHole(5.8, 8.0, 82.0) .\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().move(0, 40).lineTo(34.0, board_width+shell_thickness*2).lineTo(0, board_width+shell_thickness*2).close().cutThruAll() .\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane(centerOption=\u0026#34;CenterOfBoundBox\u0026#34;).move(holes_offset_x, holes_offset_y).rect(32.0, 32.0, forConstruction=True).vertices().hole(5.6) .\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane(centerOption=\u0026#34;CenterOfBoundBox\u0026#34;).move(holes_offset_x, holes_offset_y).hole(38.5) case_top = case_top.translate((0,0, 54.0)) I liked the way it turned out.\nIf I ever need to use any GPIO I can easily remove only that specific cover and that\u0026rsquo;s it.\nI have to mention that mounted this way, with the silicone mounts from noctua, this setup is absolutely silent. I really can\u0026rsquo;t hear the fan under 60% PWM, not even very close to it.\nThat\u0026rsquo;s about it for today, ü§òüèΩ\nThanks for reading.\n","permalink":"https://eddieliberato.github.io/blog/2022-03-10-jetson-nano/","tags":["Cad","3d printing","Cadquery"],"title":"Jetson Nano Case"},{"categories":["Engineering"],"contents":"This post is about some finite element method code that I wrote back in 2014. I am sharing it here, even though I never finished the data visualization part I wanted back then.\nTable of Contents Trusses 2D Truss Space Truss Frames Portal Frame 3D Frame I won\u0026rsquo;t write about theory after all there\u0026rsquo;s a million books out there about this subject. I\u0026rsquo;m just sharing my take on hands on code, something that you don\u0026rsquo;t usually find in books. The code is written in python.\nAt the time I was heavily inspired by Sukhbinder Singh. Go check his blog if you didn\u0026rsquo;t yet, tons of interesting stuff there. I will also leave a big thanks! for him here, in case he ever happens to read this.\nTrusses 2D Truss Let\u0026rsquo;s start simple with a 2d application of the method. This example is taken from the following book:\nHutton, D. V. (2004). Fundamentals of finite element analysis. 1st ed. Boston: McGraw-Hill. Page 69.\nThe two-element truss in Figure is subjected to external loading as shown. Using the same node and element numbering as in Figure, determine the displacement components of node 3, the reaction force components at nodes 1 and 2, and the element displacements, stresses, and forces. The elements have modulus of elasticity E1=E2=10x10^6 lb/in^2 and cross-sectional areas A1=A2=1.5 in^2.\n############################################################## # Fem script to compute plane truss displacements and stresses # written by Eddie Liberato 16/11/16 ############################################################## import numpy as np # constants E=10e06 A=1.5 # structure geometry node_coord=np.array([[0,0],[0,40],[40,40]]) # nodes coordinates elem_con=np.array([[0,2],[1,2]]) # elements connectivity x=node_coord[:,0] # sliced array with only x node coordinates y=node_coord[:,1] # sliced array with only y node coordinates node_count=len(node_coord) elem_count=len(elem_con) struct_dof=2*node_count # (entire) structure degrees of freedom # matrices initialization displacement=np.zeros((struct_dof,1)) force=np.zeros((struct_dof,1)) sigma=np.zeros((elem_count,1)) stiffness=np.zeros((struct_dof,struct_dof)) # load assignments force[4]=500 force[5]=300 # computations for e in range(elem_count): index=elem_con[e] elem_dof=np.array([index[0]*2, index[0]*2+1, index[1]*2, index[1]*2+1]) xl=x[index[1]]-x[index[0]] yl=y[index[1]]-y[index[0]] elem_length=np.sqrt(xl*xl+yl*yl) c=xl/elem_length s=yl/elem_length rot=np.array([[c*c, c*s, -c*c, -c*s], [c*s, s*s, -c*s, -s*s], [-c*c, -c*s, c*c, c*s], [-c*s, -s*s, c*s, s*s]]) k=(E*A/elem_length)*rot stiffness[np.ix_(elem_dof, elem_dof)] +=k suppress_dof=np.array([0,1,2,3]) # constrained degrees of freedom active_dof=np.setdiff1d(np.arange(struct_dof), suppress_dof) displacement_aux=np.linalg.solve(stiffness[np.ix_(active_dof,active_dof)], force[np.ix_(active_dof)]) displacement[np.ix_(active_dof)]=displacement_aux react=np.dot(stiffness, displacement) for e in range(elem_count): index=elem_con[e] elem_dof=np.array([index[0]*2, index[0]*2+1, index[1]*2, index[1]*2+1]) xl=x[index[1]]-x[index[0]] yl=y[index[1]]-y[index[0]] elem_length=np.sqrt(xl*xl+yl*yl) c=xl/elem_length s=yl/elem_length sigma[e]=(E/elem_length)*np.dot(np.array([-c,-s,c,s]), displacement[np.ix_(elem_dof)]) # emitting results to screen print(f\u0026#39;displacements:\\n {displacement}\u0026#39;) print(f\u0026#39;stress:\\n {sigma}\u0026#39;) The output:\n$ python truss2d.py displacements: [[0. ] [0. ] [0. ] [0. ] [0.00053333] [0.00172941]] stress: [[282.84271247] [133.33333333]] All right, pretty cool. Short, dense script. A lot is being done in just a few lines of code. But even cooler is the fact that you can relatively easy expand the method (and the script) to solve 3d trusses, also called space trusses.\nSpace Truss I\u0026rsquo;m taking the 3d example from the book of Darryl Logan, a book that I recommend as the first book to be read by someone studying the Finite Element Method.\nLogan D. L. (2007). A First Course in the Finite Element Method. 4th ed. Thomson. Page 98.\nAnalyze the space truss shown in Figure. The truss is composed of four nodes, whose coordinates (in meters) are shown in the figure, and three elements, whose cross-sectional areas are all 10x10^-4 m^2. The modulus of elasticity E=210 GPa for all the elements. A load of 20 kN is applied at node 1 in the global x-direction. Nodes 2‚Äì4 are pin supported and thus constrained from movement in the x, y, and z directions.\n############################################################### # Fem script to compute space truss displacements and stresses # written by Eddie Liberato 16/11/16 ############################################################### import numpy as np # constants E=210e09 A=10e-04 # structure geometry node_coord=np.array([[12,-3,-4],[0,0,0],[12,-3,-7],[14,6,0]]) # node cordenates elem_con=np.array([[0,1],[0,2],[0,3]]) # elements connectivity x=node_coord[:,0] # sliced array with only x node coord y=node_coord[:,1] # sliced array with only y node coord z=node_coord[:,2] # sliced array with only z node coord node_count=len(node_coord) elem_count=len(elem_con) struct_dof=3*node_count # (entire) structure degrees of freedom # matrices initialization displacement=np.zeros((struct_dof,1)) force=np.zeros((struct_dof,1)) sigma=np.zeros((elem_count,1)) stiffness=np.zeros((struct_dof,struct_dof)) np.set_printoptions(precision=3) # load assignments force[0]=20e03 # computations for e in range(elem_count): index=elem_con[e] elem_dof=np.array([index[0]*3, index[0]*3+1, index[0]*3+2, index[1]*3, index[1]*3+1, index[1]*3+2]) xl=x[index[1]]-x[index[0]] yl=y[index[1]]-y[index[0]] zl=z[index[1]]-z[index[0]] elem_length=np.sqrt(xl*xl+yl*yl+zl*zl) cx=xl/elem_length cy=yl/elem_length cz=zl/elem_length trans=np.array([[cx*cx,cx*cy,cx*cz,-cx*cx,-cx*cy,-cx*cz], [cy*cx,cy*cy,cy*cz,-cy*cx,-cy*cy,-cy*cz], [cz*cx,cz*cy,cz*cz,-cz*cx,-cz*cy,-cz*cz], [-cx*cx,-cx*cy,-cx*cz,cx*cx,cx*cy,cx*cz], [-cy*cx,-cy*cy,-cy*cz,cy*cx,cy*cy,cy*cz], [-cz*cx,-cz*cy,-cz*cz,cz*cx,cz*cy,cz*cz]]) k=(E*A/elem_length)*trans stiffness[np.ix_(elem_dof, elem_dof)] +=k suppress_dof=np.array([3,4,5,6,7,8,9,10,11]) # constrained degrees of freedom active_dof=np.setdiff1d(np.arange(struct_dof), suppress_dof) displacement_aux=np.linalg.solve(stiffness[np.ix_(active_dof,active_dof)], force[np.ix_(active_dof)]) displacement[np.ix_(active_dof)]=displacement_aux react=np.dot(stiffness, displacement) for e in range(elem_count): index=elem_con[e] elem_dof=np.array([index[0]*3, index[0]*3+1, index[0]*3+2, index[1]*3, index[1]*3+1, index[1]*3+2]) xl=x[index[1]]-x[index[0]] yl=y[index[1]]-y[index[0]] zl=z[index[1]]-z[index[0]] elem_length=np.sqrt(xl*xl+yl*yl+zl*zl) cx=xl/elem_length cy=yl/elem_length cz=zl/elem_length sigma[e]=(E/elem_length)*np.dot(np.array([-cx,-cy,-cz,cx,cy,cz]), displacement[np.ix_(elem_dof)]) # emitting results to screen print(f\u0026#39;reactions:\\n {react.reshape(node_count,3)}\u0026#39;) print(f\u0026#39;displacements:\\n {displacement}\u0026#39;) print(f\u0026#39;stress:\\n {sigma}\u0026#39;) The output:\n$ python truss3d.py reactions: [[ 2.000e+04 -1.137e-13 -9.095e-13] [-1.895e+04 4.737e+03 6.316e+03] [ 0.000e+00 0.000e+00 -4.211e+03] [-1.053e+03 -4.737e+03 -2.105e+03]] displacements: [[ 1.384e-03] [-5.157e-05] [ 6.015e-05] [ 0.000e+00] [ 0.000e+00] [ 0.000e+00] [ 0.000e+00] [ 0.000e+00] [ 0.000e+00] [ 0.000e+00] [ 0.000e+00] [ 0.000e+00]] stress: [[20526315.789] [ 4210526.316] [-5289408.222]] Frames Portal Frame A brief tale about how this started: My young self trying to design a bamboo bicycle frame. Unfortunately the bike itself never passed the drawing board stage, but in the process I learned a lot about mechanical structures and designing things using unusual materials. Here I share part of the effort, more specifically, the efforts to calculate the forces on members of the frame.\nAs you\u0026rsquo;ll see the examples are not about bike frames, but simpler structures. This is due to the fact that I don\u0026rsquo;t want to (re)write about theory here. I just want to share hands on code. The examples are taken from a book where you can find more detailed explanation about conceptual part of the method.\nLogan D. L. (2007). A First Course in the Finite Element Method. 4th ed. Thomson. Page 218.\nAs the first example of rigid plane frame analysis, solve the simple ‚Äò‚Äòbent‚Äô‚Äô. The frame is fixed at nodes 1 and 4 and subjected to a positive horizontal force of 10,000 lb applied at node 2 and to a positive moment of 5000 lb-in. applied at node 3. The global-coordinate axes and the element lengths are shown in Figure. Let E=30x10^6 psi and A=10 in^2 for all elements, and let I=200 in^4 for elements 1 and 3, and I=100^4 for element 2.\n############################################################### # Fem script to compute plane frame forces and moments # written by Eddie Liberato 16/11/16 ############################################################### import numpy as np # constants E=30e06 # psi A=10 # in^2 I=[200,100,200] # in^4 # structure geometry node_coord=np.array([[0,0],[0,10*12],[10*12,10*12],[10*12,0]]) # node coordinates elem_con=np.array([[0,1],[1,2],[2,3]]) # elements connectivity x=node_coord[:,0] # sliced array with only x node coord y=node_coord[:,1] # sliced array with only y node coord node_count=len(node_coord) elem_count=len(elem_con) struct_dof=3*node_count # (entire) structure degrees of freedom # matrices initialization displacement=np.zeros((struct_dof,1)) force=np.zeros((struct_dof,1)) stiffness=np.zeros((struct_dof,struct_dof)) # load assignments force[3]=10000 force[8]=5000 # computations for e in range(elem_count): index=elem_con[e] elem_dof=np.array([index[0]*3, index[0]*3+1, index[0]*3+2, index[1]*3, index[1]*3+1, index[1]*3+2]) xl=x[index[1]]-x[index[0]] yl=y[index[1]]-y[index[0]] el=np.sqrt(xl*xl+yl*yl) c=xl/el s=yl/el kglobal=(E/el)*np.array([[A*c**2+12*I[e]/el**2*s**2,(A-12*I[e]/el**2)*c*s,-6*I[e]/el*s,-(A*c**2+12*I[e]/el**2*s**2),-(A-12*I[e]/el**2)*c*s,-(6*I[e]/el)*s], [(A-12*I[e]/el**2)*c*s, A*s**2+12*I[e]/el**2*c**2, 6*I[e]/el*c, -(A-12*I[e]/el**2)*c*s, -(A*s**2+12*I[e]/el**2*c**2), (6*I[e]/el)*c], [-6*I[e]/el*s, 6*I[e]/el*c, 4*I[e], 6*I[e]/el*s, -(6*I[e]/el)*c, 2*I[e]], [-(A*c**2+12*I[e]/el**2*s**2),-(A-12*I[e]/el**2)*c*s, 6*I[e]/el*s, A*c**2+12*I[e]/el**2*s**2, (A-12*I[e]/el**2)*c*s, 6*I[e]/el*s], [-(A-12*I[e]/el**2)*c*s, -(A*s**2+12*I[e]/el**2*c**2), -(6*I[e]/el)*c, (A-12*I[e]/el**2)*c*s, A*s**2+12*I[e]/el**2*c**2, -(6*I[e]/el)*c], [-(6*I[e]/el)*s, (6*I[e]/el)*c, 2*I[e], 6*I[e]/el*s, -(6*I[e]/el)*c, 4*I[e]]]) stiffness[np.ix_(elem_dof, elem_dof)] +=kglobal suppress_dof=np.array([0,1,2,9,10,11]) active_dof=np.setdiff1d(np.arange(struct_dof), suppress_dof) displacement_aux=np.linalg.solve(stiffness[np.ix_(active_dof,active_dof)], force[np.ix_(active_dof)]) displacement[np.ix_(active_dof)]=displacement_aux print(f\u0026#39;displacements:\\n {displacement}\u0026#39;) for e in range(elem_count): print(f\u0026#39;forces on element {e+1}\u0026#39;) index=elem_con[e] elem_dof=np.array([index[0]*3, index[0]*3+1, index[0]*3+2, index[1]*3, index[1]*3+1, index[1]*3+2]) xl=x[index[1]]-x[index[0]] yl=y[index[1]]-y[index[0]] el=np.sqrt(xl*xl+yl*yl) c=xl/el s=yl/el trans=np.array([[c,s,0,0,0,0],[-s,c,0,0,0,0],[0,0,1,0,0,0],[0,0,0,c,s,0],[0,0,0,-s,c,0],[0,0,0,0,0,1]]) Td=np.dot(trans, displacement[np.ix_(elem_dof)]) c1=(A*E/el) c2=(E*I[e]/el**3) klocal=np.array([[c1,0,0,-c1,0,0], [0,12*c2,6*c2*el,0,-12*c2,6*c2*el],[0,6*c2*el,4*c2*el**2,0,-6*c2*el,2*c2*el**2], [-c1,0,0,c1,0,0], [0,-12*c2,-6*c2*el,0,12*c2,-6*c2*el], [0,6*c2*el,2*c2*el**2,0,-6*c2*el,4*c2*el**2]]) elem_forces=np.dot(klocal,Td) print(f\u0026#39;{elem_forces}\u0026#39;) The output:\n$ python frame2d.py displacements: [[ 0. ] [ 0. ] [ 0. ] [ 0.21136266] [ 0.00148133] [-0.00152603] [ 0.20935933] [-0.00148133] [-0.001486 ] [ 0. ] [ 0. ] [ 0. ]] forces on element 1 [[ -3703.31950207] [ 4991.69435216] [375803.32156987] [ 3703.31950207] [ -4991.69435216] [223200.00068927]] forces on element 2 [[ 5008.30564784] [ -3703.31950207] [-223200.00068927] [ -5008.30564784] [ 3703.31950207] [-221198.3395597 ]] forces on element 3 [[ 3703.31950207] [ 5008.30564784] [226198.3395597 ] [ -3703.31950207] [ -5008.30564784] [374798.33818117]] 3D Frame Finally the script I used in practice when I was designing the bike, the 3d frame. Things get interesting and relatively complex here. You\u0026rsquo;ll need to care about directions and torsional parameters. Not for the faint of heart.\nThere\u0026rsquo;s a bit of bloat there because I failed the don\u0026rsquo;t repeat yourself mantra. I said to myself I\u0026rsquo;d come back later and rewrite that part but ended up never doing it.\nLogan D. L. (2007). A First Course in the Finite Element Method. 4th ed. Thomson. Page 262.\nDetermine the displacements and rotations at the free node (node 1) and the element local forces and moments for the space frame shown in Figure. Also verify equilibrium at node 1. Let E=30 000 Ksi, G=10 000 Ksi, J=50 in^4, Iy=100 in^4, Iz=100 in^4, A=10 in^2, and L=100 inches for all three beam elements.\n############################################################### # Fem script to compute space frame forces and moments # written by Eddie Liberato 16/11/16 ############################################################### import numpy as np # constants E=30e03 # psi A=10 # in^2 Iy=100 Iz=100 Gs=10000 Jt=50 # structure geometry node_coord=np.array([[0,0,0],[-100,0,0],[0,0,-100],[0,-100,0]]) # node coordinates elem_con=np.array([[1,0],[2,0],[3,0]]) # elements connectivity xx=node_coord[:,0] # sliced array with only x node coord yy=node_coord[:,1] # sliced array with only y node coord zz=node_coord[:,2] # sliced array with only z node coord node_count=len(node_coord) elem_count=len(elem_con) struct_dof=6*node_count # (entire) structure degrees of freedom # matrices initialization displacement=np.zeros((struct_dof,1)) force=np.zeros((struct_dof,1)) stiffness=np.zeros((struct_dof,struct_dof)) np.set_printoptions(precision=3) # load assignments force[1]=-50 force[3]=-1000 # computations for e in range(elem_count): index=elem_con[e] elem_dof=np.array([index[0]*6, index[0]*6+1, index[0]*6+2, index[0]*6+3, index[0]*6+4, index[0]*6+5, index[1]*6, index[1]*6+1, index[1]*6+2, index[1]*6+3, index[1]*6+4, index[1]*6+5]) xl=xx[index[1]]-xx[index[0]] yl=yy[index[1]]-yy[index[0]] zl=zz[index[1]]-zz[index[0]] el=np.sqrt(xl*xl+yl*yl+zl*zl) lx=xl/el mx=yl/el nx=zl/el Di=np.sqrt(lx*lx+mx*mx) if Di==0 and nx\u0026gt;0: transf=np.array([[0,0,1,0,0,0,0,0,0,0,0,0], [0,1,0,0,0,0,0,0,0,0,0,0], [-1,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,1,0,0,0,0,0,0], [0,0,0,0,1,0,0,0,0,0,0,0], [0,0,0,-1,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,1,0,0,0], [0,0,0,0,0,0,0,1,0,0,0,0], [0,0,0,0,0,0,-1,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,1], [0,0,0,0,0,0,0,0,0,0,1,0], [0,0,0,0,0,0,0,0,0,-1,0,0]]) elif Di==0 and nx\u0026lt;0: transf=np.array([[0,0,-1,0,0,0,0,0,0,0,0,0], [0,1,0,0,0,0,0,0,0,0,0,0], [1,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,-1,0,0,0,0,0,0], [0,0,0,0,1,0,0,0,0,0,0,0], [0,0,0,1,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,-1,0,0,0], [0,0,0,0,0,0,0,1,0,0,0,0], [0,0,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,-1], [0,0,0,0,0,0,0,0,0,0,1,0], [0,0,0,0,0,0,0,0,0,1,0,0]]) else: ly=-mx/Di my=lx/Di ny=0 lz=-lx*nx/Di mz=-mx*nx/Di nz=Di transf=np.array([[lx,mx,nx,0,0,0,0,0,0,0,0,0], [ly,my,ny,0,0,0,0,0,0,0,0,0], [lz,mz,nz,0,0,0,0,0,0,0,0,0], [0,0,0,lx,mx,nx,0,0,0,0,0,0], [0,0,0,ly,my,ny,0,0,0,0,0,0], [0,0,0,lz,mz,nz,0,0,0,0,0,0], [0,0,0,0,0,0,lx,mx,nx,0,0,0], [0,0,0,0,0,0,ly,my,ny,0,0,0], [0,0,0,0,0,0,lz,mz,nz,0,0,0], [0,0,0,0,0,0,0,0,0,lx,mx,nx], [0,0,0,0,0,0,0,0,0,ly,my,ny], [0,0,0,0,0,0,0,0,0,lz,mz,nz]]) klocal=np.array([[A*E/el,0,0,0,0,0,-A*E/el,0,0,0,0,0], [0,12*E*Iz/el**3,0,0,0,6*E*Iz/el**2,0,-12*E*Iz/el**3,0,0,0,6*E*Iz/el**2], [0,0,12*E*Iy/el**3,0,-6*E*Iy/el**2,0,0,0,-12*E*Iy/el**3,0,-6*E*Iy/el**2,0], [0,0,0,Gs*Jt/el,0,0,0,0,0,-Gs*Jt/el,0,0], [0,0,-6*E*Iy/el**2,0,4*E*Iy/el,0,0,0,6*E*Iy/el**2,0,2*E*Iy/el,0], [0,6*E*Iz/el**2,0,0,0,4*E*Iz/el,0,-6*E*Iz/el**2,0,0,0,2*E*Iz/el], [-A*E/el,0,0,0,0,0,A*E/el,0,0,0,0,0], [0,-12*E*Iz/el**3,0,0,0,-6*E*Iz/el**2,0,12*E*Iz/el**3,0,0,0,-6*E*Iz/el**2], [0,0,-12*E*Iy/el**3,0,6*E*Iy/el**2,0,0,0,12*E*Iy/el**3,0,6*E*Iy/el**2,0], [0,0,0,-Gs*Jt/el,0,0,0,0,0,Gs*Jt/el,0,0], [0,0,-6*E*Iy/el**2,0,2*E*Iy/el,0,0,0,6*E*Iy/el**2,0,4*E*Iy/el,0], [0,6*E*Iz/el**2,0,0,0,2*E*Iz/el,0,-6*E*Iz/el**2,0,0,0,4*E*Iz/el]]) tptf=np.transpose(transf) tpklprod=np.dot(tptf,klocal) kglobal=np.dot(tpklprod,transf) stiffness[np.ix_(elem_dof, elem_dof)] +=kglobal suppress_dof=np.array([6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]) active_dof=np.setdiff1d(np.arange(struct_dof), suppress_dof) displacement_aux=np.linalg.solve(stiffness[np.ix_(active_dof,active_dof)], force[np.ix_(active_dof)]) displacement[np.ix_(active_dof)]=displacement_aux print(f\u0026#39;displacements:\\n {displacement}\u0026#39;) for e in range(elem_count): print(f\u0026#39;forces on element {e+1}\u0026#39;) index=elem_con[e] elem_dof=np.array([index[0]*6, index[0]*6+1, index[0]*6+2, index[0]*6+3, index[0]*6+4, index[0]*6+5, index[1]*6, index[1]*6+1, index[1]*6+2, index[1]*6+3, index[1]*6+4, index[1]*6+5]) xl=xx[index[1]]-xx[index[0]] yl=yy[index[1]]-yy[index[0]] zl=zz[index[1]]-zz[index[0]] el=np.sqrt(xl*xl+yl*yl+zl*zl) lx=xl/el mx=yl/el nx=zl/el Di=np.sqrt(lx*lx+mx*mx) if Di==0 and nx\u0026gt;0: transf=np.array([[0,0,1,0,0,0,0,0,0,0,0,0], [0,1,0,0,0,0,0,0,0,0,0,0], [-1,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,1,0,0,0,0,0,0], [0,0,0,0,1,0,0,0,0,0,0,0], [0,0,0,-1,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,1,0,0,0], [0,0,0,0,0,0,0,1,0,0,0,0], [0,0,0,0,0,0,-1,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,1], [0,0,0,0,0,0,0,0,0,0,1,0], [0,0,0,0,0,0,0,0,0,-1,0,0]]) elif Di==0 and nx\u0026lt;0: transf=np.array([[0,0,-1,0,0,0,0,0,0,0,0,0], [0,1,0,0,0,0,0,0,0,0,0,0], [1,0,0,0,0,0,0,0,0,0,0,0], [0,0,0,0,0,-1,0,0,0,0,0,0], [0,0,0,0,1,0,0,0,0,0,0,0], [0,0,0,1,0,0,0,0,0,0,0,0], [0,0,0,0,0,0,0,0,-1,0,0,0], [0,0,0,0,0,0,0,1,0,0,0,0], [0,0,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,0,0,0,0,-1], [0,0,0,0,0,0,0,0,0,0,1,0], [0,0,0,0,0,0,0,0,0,1,0,0]]) else: ly=-mx/Di my=lx/Di ny=0 lz=-lx*nx/Di mz=-mx*nx/Di nz=Di transf=np.array([[lx,mx,nx,0,0,0,0,0,0,0,0,0], [ly,my,ny,0,0,0,0,0,0,0,0,0], [lz,mz,nz,0,0,0,0,0,0,0,0,0], [0,0,0,lx,mx,nx,0,0,0,0,0,0], [0,0,0,ly,my,ny,0,0,0,0,0,0], [0,0,0,lz,mz,nz,0,0,0,0,0,0], [0,0,0,0,0,0,lx,mx,nx,0,0,0], [0,0,0,0,0,0,ly,my,ny,0,0,0], [0,0,0,0,0,0,lz,mz,nz,0,0,0], [0,0,0,0,0,0,0,0,0,lx,mx,nx], [0,0,0,0,0,0,0,0,0,ly,my,ny], [0,0,0,0,0,0,0,0,0,lz,mz,nz]]) Td=np.dot(transf, displacement[np.ix_(elem_dof)]) klocal=np.array([[A*E/el,0,0,0,0,0,-A*E/el,0,0,0,0,0], [0,12*E*Iz/el**3,0,0,0,6*E*Iz/el**2,0,-12*E*Iz/el**3,0,0,0,6*E*Iz/el**2], [0,0,12*E*Iy/el**3,0,-6*E*Iy/el**2,0,0,0,-12*E*Iy/el**3,0,-6*E*Iy/el**2,0], [0,0,0,Gs*Jt/el,0,0,0,0,0,-Gs*Jt/el,0,0], [0,0,-6*E*Iy/el**2,0,4*E*Iy/el,0,0,0,6*E*Iy/el**2,0,2*E*Iy/el,0], [0,6*E*Iz/el**2,0,0,0,4*E*Iz/el,0,-6*E*Iz/el**2,0,0,0,2*E*Iz/el], [-A*E/el,0,0,0,0,0,A*E/el,0,0,0,0,0], [0,-12*E*Iz/el**3,0,0,0,-6*E*Iz/el**2,0,12*E*Iz/el**3,0,0,0,-6*E*Iz/el**2], [0,0,-12*E*Iy/el**3,0,6*E*Iy/el**2,0,0,0,12*E*Iy/el**3,0,6*E*Iy/el**2,0], [0,0,0,-Gs*Jt/el,0,0,0,0,0,Gs*Jt/el,0,0], [0,0,-6*E*Iy/el**2,0,2*E*Iy/el,0,0,0,6*E*Iy/el**2,0,4*E*Iy/el,0], [0,6*E*Iz/el**2,0,0,0,2*E*Iz/el,0,-6*E*Iz/el**2,0,0,0,4*E*Iz/el]]) elem_forces=np.dot(klocal,Td) print(f\u0026#39;{elem_forces}\u0026#39;) The output:\n$ python frame3d.py displacements: [[ 7.098e-05] [-1.400e-02] [-2.352e-03] [-3.996e-03] [ 1.780e-05] [-1.033e-04] [ 0.000e+00] [ 0.000e+00] [ 0.000e+00] [ 0.000e+00] [ 0.000e+00] [ 0.000e+00] [ 0.000e+00] [ 0.000e+00] [ 0.000e+00] [ 0.000e+00] [ 0.000e+00] [ 0.000e+00] [ 0.000e+00] [ 0.000e+00] [ 0.000e+00] [ 0.000e+00] [ 0.000e+00] [ 0.000e+00]] forces on element 1 [[ -0.213] [ 0.318] [ 0.053] [ 19.98 ] [ -3.165] [ 18.991] [ 0.213] [ -0.318] [ -0.053] [-19.98 ] [ -2.097] [ 12.79 ]] forces on element 2 [[ 7.056e+00] [ 7.697e+00] [-2.949e-02] [ 5.167e-01] [ 9.403e-01] [ 2.650e+02] [-7.056e+00] [-7.697e+00] [ 2.949e-02] [-5.167e-01] [ 2.008e+00] [ 5.047e+02]] forces on element 3 [[ 4.199e+01] [-1.835e-01] [-7.108e+00] [-8.900e-02] [ 2.355e+02] [-6.073e+00] [-4.199e+01] [ 1.835e-01] [ 7.108e+00] [ 8.900e-02] [ 4.753e+02] [-1.227e+01]] This last script craves for refactoring, but hey, it works. At the time I wanted to find some visualization library, rewrite and expand the code. I thought I\u0026rsquo;d post it only after it was finished. Fast forward to 2022, I realized I won\u0026rsquo;t do it anytime soon as I don\u0026rsquo;t design structural things anymore. There it is, anyway. Hopefully it can help someone.\nCheers,\nEdi\n","permalink":"https://eddieliberato.github.io/blog/2022-02-28-direct-stiffness-method/","tags":["python","Programming"],"title":"Direct Stiffness Method in Python: Trusses and Frames"},{"categories":["Programming"],"contents":"I\u0026rsquo;ve been writing for blogs since 2009 and I always wanted to write about gears. Finally the time has come.\nI can hear a voice among the crowd: If took you so long, better be something like a differential helix angle, differential tip diameter herringbone gear.\nAh, you guys mean a liberato gear?\nJoking apart, I was just blown away with how easy it is to apply transformations to f-rep models and end up with cool strange geometries.\nI will elaborate a bit more how I got to the gear you can see in the image above and in the process I\u0026rsquo;ll try to show how I modeled simple gears, like spur and helical gears.\nThe Idea\nThe way I designed the gear here is kind of unusual, so I think it needs a bit of explanation.\nA F-rep model can be created using implicit equations in libfive. So I thought to myself it would be nice to have an implicit equation of an involute to start with. The problem is that the involute curve is usually represented as a parametric equation.\nThe interesting \u0026ldquo;discovery\u0026rdquo; was that it is indeed possible to have an implicit equation of an involute, the derivation of the equation is easy but not obvious. Even more interesting to me is that I found the solution in a book from 1865.\nPrice, B (1865). A Treatise on Infinitesimal Calculus, Volume II: Integral Calculus, Calculus of Variations, and Differential Equations. 2nd ed. Oxford at the Clarendon Press.\nLet\u0026rsquo;s take a look at the full script to generate the gear you can see in the opening image of the post and after that I\u0026rsquo;ll break down the important parts.\nSOME IMPORTANT NOTES:\nI\u0026rsquo;m not following some LISP conventions: global variables should be named in between asteriscs (like a did with z, number of teeth for us mechanics, an axis for matemathicians), and you should use them wisely. I\u0026rsquo;m not following this conventions because I see this as a short script, not a long code for a library. I think it is more readable like this and I like to have the parameters I\u0026rsquo;ll probably change on top of the script. Just a side note, I like how lisp doesn\u0026rsquo;t force you to some rules, just states conventions.\nI personally don\u0026rsquo;t like so much short, one or two characters, variables names. Again, I\u0026rsquo;m coding this way because I feel it\u0026rsquo;s a bit more readable in the sense it follows the notation of mechanics. I recommend the tec-science website as a more detailed source of info on gear calculations. I tried to follow more or less the naming of variables that they use.\nI\u0026rsquo;m not adding profile shift.\nI\u0026rsquo;m not claiming cool looking gears are better than traditional gears.\n(define module 1) (define *z* 20) ; number of teeth (define pa (/ pi 12)) ; pressure angle in radians (define thickness 10) ; gear thickness, mm (define d0 (* module *z*)) ; reference pitch circle diameter (define db (* d0 (cos pa))) ; base circle diameter (define da (* module (+ *z* 2))) ; addendum circle diameter (define rb (/ db 2)) ; base circle radius (define ra (/ da 2)) ; addendum circle radius (define alpha2 (/ pi *z*)) ; tooth angular distance in radians (define eb2 (* (/ module 4) pi (cos pa))) ; tooth width spacing (define clea (* (/ 5 32) module)) ; dedendum clearance (define dd (- (* module (- *z* 2)) (* 2 clea))) ; root diameter (define-shape (involute x y z) (+ (* x (cos (* (/ 1 rb) (sqrt (+ (* x x) (* y y) (- (* rb rb))))))) (* y (sin (* (/ 1 rb) (sqrt (+ (* x x) (* y y) (- (* rb rb))))))) (- rb))) (define right-contour (rotate-z (difference (inverse involute) (-(lambda-shape (x y z) (- rb x))) (rotate-z (lambda-shape (x y z) (- y)) (/ alpha2 2))) (- (/ alpha2 2)))) (define left-contour (reflect-y right-contour)) (define tooth (union right-contour left-contour)) (define spur-gear (difference (union (array-polar tooth *z*) (circle rb) (array-polar (circle eb2 [rb 0]) *z*)) (inverse (circle ra)) (array-polar (rotate-z (rounded-rectangle [(/ dd 2 ) (- eb2)] [ra eb2] (/ module 2)) alpha2) *z*))) (define lower-side (remap-shape ((extrude spur-gear (- (/ thickness 2)) 0) x y z) (+ (* (cos (/ z 7)) x) (* (sin (/ z 5)) y)) (- (* (cos (/ z 7)) y) (* (sin (/ z 5)) x)) z)) (define liberato-gear (union lower-side (reflect-z lower-side))) liberato-gear (set-quality! 11) (set-resolution! 20) (set-bounds! [-20 -20 -6] [20 20 6]) As you can see the complicated part is to generate a tooth profile. After you achieve that, you go to town.\nThe trick to create the involute profile resides in defining a shape using the implicit involute equation. In libfive equations can create shapes within the bounds set in the end of the script.\n(define-shape (involute x y z) (+ (* x (cos (* (/ 1 rb) (sqrt (+ (* x x) (* y y) (- (* rb rb))))))) (* y (sin (* (/ 1 rb) (sqrt (+ (* x x) (* y y) (- (* rb rb))))))) (- rb))) Once we have the involute shape, the idea is to trim away everything that\u0026rsquo;s not relevant to define one side of the tooth. After that the shape is rotated back so it sits along the x axis, making it easier to reflect the half shape and end up with a involute gear tooth.\n(define right-contour (rotate-z (difference (inverse involute) (-(lambda-shape (x y z) (- rb x))) (rotate-z (lambda-shape (x y z) (- y)) (/ alpha2 2))) (- (/ alpha2 2)))) (define left-contour (reflect-y right-contour)) (define tooth (union right-contour left-contour)) Here is a close up on the profile generated, 20¬∫ degrees pressure angle (pi/9 in radians), approx 15.6 % (5/32) of module added to the dedendum as clearance. There\u0026rsquo;s a module/2 sized fillet on the root, just to break the sharp corners.\nThe last image is just to showcase some gears that are easily generated having the spur-gear modeled. To have the helical gear you simply apply the remap-shape method. For a herringbone gear you just reflect the helical gear and bob is your uncle. These models were rendered in blender.\nUpper left: spur gear Upper right: helical gear Lower left: herringbone gear Lower right: differential helix angle gear\nHope you found this as interesting as I did !\nCheers!\n","permalink":"https://eddieliberato.github.io/blog/2020-09-21-gears/","tags":["Libfive","Scheme","Lisp","Cad"],"title":"f-rep Gears"},{"categories":["Programming"],"contents":"One line of code and you have it! Weird? Cool? Wizardry?\nWhat\u0026rsquo;s a g√∂mb√∂c, anyway?\nWikipedia defines it as:\nThe g√∂mb√∂c is a convex three-dimensional homogeneous body that when resting on a flat surface has just one stable and one unstable point of equilibrium.\nThat was probably written by mathematicians, I\u0026rsquo;ll try to describe it in a simpler way.\nIt\u0026rsquo;s an object that is self-righting due to its shape.\nLet\u0026rsquo;s compare it to a weeble toy, probably a better known self-righting object. The weeble comes back to the resting position because it has something heavier than the rest of the body in its bottom. So it relies on different densities to perform its trick. A g√∂mb√∂c body instead has the same density everywhere, so it relies on its shape to come back to the equilibrium point.\nThe definition says it has two points of equilibrium, one stable and one unstable. That means it will always come back to the same position because even though formally it has another equilibrium point, this one is unstable. It would be like trying to have a pencil standing on its tip, theoretically possible, but unlikely in practice because any perturbation would knock it down.\nOn the internet I\u0026rsquo;ve found an interesting read about the story of the g√∂mboc and that something similar can be found in nature, on turtles.\nBy now you\u0026rsquo;re probably saying: Ok, got it. Well, you started this by saying it took you one line of code to model, can you share it then?\nSure\n(morph (sphere 1) (extrude (rectangle [-0.01 -1.2] [0.01 1.2]) 0.25 1.1) 0.2) Needless to say it is a bit of a joke with the fact that we are in 2020 and some people still measure productivity using lines of code (LOC) as metric.\nI have two things to say about this, First that we need to always ask ourselves if we are using the right tool for the job, second that we are always hiding complexity in libraries.\nI modeled this using libfive. It is a fantastic piece of software that uses f-rep to model solids. I love that it uses Scheme ( a subset of Lisp ) for high level scripting. It\u0026rsquo;s really amazing the way Lisp enables you to easily create complexity by adding layers of lesser complexity. Very powerful.\nThis is the kind of computing that makes computers fun, playful, interesting and sometimes disturbing things that they are.\nThank you for reading,\nEdi\n","permalink":"https://eddieliberato.github.io/blog/2020-08-12-gomboc/","tags":["Libfive","Scheme","Lisp","Cad"],"title":"G√∂mb√∂c"},{"categories":["Programming"],"contents":"No need to say much about the classical ASTM D638 tensile test specimens AKA dogbones. Just a few remarks:\nType I, II, III, and V have the same shape but different dimensions. Type I is usually injection molded. Type V is usually cut using punch dies. Type IV is intended for non-rigid plastics. Thickness of 3.2 mm is recommended for injection molded specimens. Figure above reference:ASTM D638, Standard Test Method for Tensile Properties of Plastics, ASTM International, West Conshohocken, PA, 2014, www.astm.org\nCadquery scripts:\nimport cadquery as cq # ASTM D638 typeI dogbone W = 13.0 L = 57.0 WO = 19.0 LO = 165.0 R = 76.0 thickness = 3.2 dogbone_typeI = (cq.Workplane(\u0026#34;front\u0026#34;).box(LO, WO, thickness). faces(\u0026#34;\u0026gt;Y\u0026#34;).workplane().rect(L, thickness).cutBlind(-(WO-W)/2). faces(\u0026#34;\u0026lt;Y\u0026#34;).workplane().rect(L, thickness).cutBlind(-(WO-W)/2). faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane(centerOption=\u0026#39;CenterOfBoundBox\u0026#39;). rect(L, 2*R+W, forConstruction=True).vertices().hole(2*R)) show_object(dogbone_typeI) import cadquery as cq # ASTM D638 typeIV dogbone W = 6.0 L = 33.0 WO = 19.0 LO = 115.0 R = 14.0 RO = 25.0 thickness = 3.2 dogbone_typeIV = (cq.Workplane(\u0026#34;front\u0026#34;).box(LO, WO, thickness). faces(\u0026#34;\u0026gt;Y\u0026#34;).workplane().rect(L, thickness).cutBlind(-(WO-W)/2). faces(\u0026#34;\u0026lt;Y\u0026#34;).workplane().rect(L, thickness).cutBlind(-(WO-W)/2). faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane(centerOption=\u0026#39;CenterOfBoundBox\u0026#39;). rect(L, 2*R+W, forConstruction=True).vertices().hole(R*2). edges(\u0026#34;|Z\u0026#34;).edges(\u0026#34;not \u0026lt;X or \u0026gt;X\u0026#34;).fillet(RO)) show_object(dogbone_typeIV) ","permalink":"https://eddieliberato.github.io/blog/2020-05-14-dogbones/","tags":["cadquery","python","3D printing","CAD"],"title":"ASTM D638 Tensile Test Specimens"},{"categories":["Programming"],"contents":"A weird project to test my new 3d printer: A chess set designed in cadquery.\nNote from the future: This coding style is grossly outdated and kept here only as archive of the past. Cadquery changed a lot over the years. Nowadays we have assemblies support, for instance.\n# Chess set import cadquery as cq # Chess board squares size cbss = 25 right_side_up_pawns = True # False is probably better for 3d printing # king base diameter and height kb = cbss*0.75 kh = kb*2.5 king = cq.Workplane(\u0026#34;front\u0026#34;).circle(kb/2).workplane(offset=kh*0.7).circle(kb*0.8/2).loft(combine=True).\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().circle(kb*0.8/2).workplane(offset=kh*0.1).circle(kb*0.4/2).loft(combine=True).\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().circle(kb*0.4/2).workplane(offset=kh*0.08).circle(kb*0.7/2).loft(combine=True).\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().circle(kb*0.7/2).workplane(offset=kh*0.12).polygon(4, kb).loft(combine=True).\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).hole(kb*0.75,kh*0.03).translate((0,cbss*3,0)) queen = cq.Workplane(\u0026#34;front\u0026#34;).circle(kb/2).workplane(offset=kh*0.5).circle(kb*0.6/2).loft(combine=True). \\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().circle(kb*0.6/2).workplane(offset=kh*0.12).circle(kb/2).loft(combine=True). \\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().circle(kb/2).workplane(offset=kh*0.1).circle(kb*0.4/2).loft(combine=True). \\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().circle(kb*0.4/2).workplane(offset=kh*0.1).circle(kb*0.9/2).loft(combine=True). \\ faces(\u0026#34;\u0026gt;Z\u0026#34;).hole(kb*0.6,kh*0.03) .\\ faces(\u0026#34;\u0026gt;Z[-2]\u0026#34;).workplane().circle(kb*0.4/2).extrude(kh*0.05) .\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).fillet(kh*0.05-0.1).translate((0,cbss*4,0)) def rook(): rk = cq.Workplane(\u0026#34;front\u0026#34;).circle(kb/2).workplane(offset=kh*0.7).polygon(4, kb*1.6).loft(combine=True). \\ faces(\u0026#34;\u0026gt;Z\u0026#34;).hole(kb*1.2,kh*0.05) return rk def knight(): mouth = cq.Workplane(\u0026#34;top\u0026#34;).polygon(4, kb*0.8).extrude(kb*2).translate((kb*0.75,-kb,kb*1.3)) kn = cq.Workplane(\u0026#34;front\u0026#34;).circle(kb/2).workplane(offset=kh*0.7).center(-kb*0.1,0).polygon(2, kb*1.5).loft(combine=True) kn = kn.cut(mouth) return kn def bishop(): hat = cq.Workplane(\u0026#34;front\u0026#34;).circle(kb*0.6/2).workplane(offset=kh*0.2).polygon(4,kb*1.2).loft(combine=True). \\ faces(\u0026#34;\u0026gt;Z\u0026#34;).center(-kb*0.2,0).cskHole(kb*0.4,kb,72).translate((0,0,kh*0.5)) bi = cq.Workplane(\u0026#34;front\u0026#34;).circle(kb/2).workplane(offset=kh*0.5).circle(kb*0.6/2).loft(combine=True) bi = bi.add(hat).combine() return bi def pawn(): pa = cq.Workplane(\u0026#34;front\u0026#34;).circle(kb/2).extrude(kh*0.1) .\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().circle(kb*0.4/2).workplane(offset=kh*0.25).circle(kb/2).loft(combine=True) .\\ edges(\u0026#34;not\u0026gt;Z\u0026#34;).fillet(kb*0.1) if right_side_up_pawns: pa = pa.rotate((0,0,0), (1,0,0),180).translate((0,0,kh*0.35)) return pa Lrook = rook() Rrook = rook().translate((0, cbss*7, 0)) Lknight = knight().translate((0, cbss, 0)) Rknight = knight().translate((0, cbss*6, 0)) Lbishop = bishop().translate((0, cbss*2, 0)) Rbishop = bishop().translate((0, cbss*5, 0)) Lrook_pawn = pawn().translate((cbss, 0, 0)) Lknight_pawn = pawn().translate((cbss, cbss, 0)) Lbishop_pawn = pawn().translate((cbss, cbss*2, 0)) king_pawn = pawn().translate((cbss, cbss*3, 0)) queen_pawn = pawn().translate((cbss, cbss*4, 0)) Rbishop_pawn = pawn().translate((cbss, cbss*5, 0)) Rknight_pawn = pawn().translate((cbss, cbss*6, 0)) Rrook_pawn = pawn().translate((cbss, cbss*7, 0)) chess_set = king.add(queen).add(Lrook).add(Rrook).add(Lknight).add(Rknight) .\\ add(Lbishop).add(Rbishop).add(Lrook_pawn).add(Lknight_pawn) .\\ add(Lbishop_pawn).add(king_pawn).add(queen_pawn).add(Rbishop_pawn) .\\ add(Rknight_pawn).add(Rrook_pawn).combine() #show #show_object(Lrook, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Lknight, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Lbishop, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(queen, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(king, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Rbishop, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Rknight, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Rrook, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Lrook_pawn, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Lknight_pawn, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Lbishop_pawn, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(king_pawn, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(queen_pawn, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Rbishop_pawn, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Rknight_pawn, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Rrook_pawn, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) show_object(chess_set, options={\u0026#34;rgba\u0026#34;:(130, 185, 255, 0.0)}) Some final comments about the script: I read an article here to more or less have some guidance about the parameters. The diameter of the bottom of the pieces should be 75% of the playing square and the height should be 2.5 x that number. They call this the 75% guideline.\nIt\u0026rsquo;s a bit unusual object to draw using parametric CAD and probably easier with point and click softwares but it was an interesting parametric exercise. I had a lot of fun coding the pieces and printing them.\nThanks for looking\nEdi\n","permalink":"https://eddieliberato.github.io/blog/2018-06-26-cadquery-chess-set/","tags":["cadquery","python","3D printing","CAD"],"title":"Cadquery Chess Set"}]